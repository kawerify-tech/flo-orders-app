 rules_version = '2'; 
 service cloud.firestore {
   match /databases/{database}/documents {

     function isSignedIn() {
       return request.auth != null;
     }

     function isAdmin() {
       return isSignedIn() && request.auth.token.role == "admin";
     }

     function isAttendant() {
       return isSignedIn() && exists(/databases/$(database)/documents/attendants/$(request.auth.uid));
     }

     // Used for subcollections where resource is not the client document.
     function isClientOwner(clientId) {
       return isSignedIn() && (
         get(/databases/$(database)/documents/clients/$(clientId)).data.email == request.auth.token.email
         || get(/databases/$(database)/documents/clients/$(clientId)).data.uid == request.auth.uid
       );
     }

     function isValidTransactionUpdate() {
       return isAttendant() && 
              request.resource.data.status in ['completed', 'rejected'] &&
              request.resource.data.attendantId == request.auth.uid;
     }

     match /{collection}/{docId} {
       allow read, write: if isSignedIn();
     }

     match /admins/{docId} {
       allow read, write: if isAdmin();
     }

     match /attendants/{attendantId} {
      allow read: if isSignedIn();
      allow list: if isSignedIn() && request.query.limit <= 1;
      // Needed for attendant Settings screen (getDoc + setDoc merge)
      allow update: if isAdmin() || (
        isSignedIn() && (
          request.auth.uid == attendantId
          || resource.data.email == request.auth.token.email
          || resource.data.uid == request.auth.uid
        )
      );
      allow create, delete: if isAdmin();

       match /transactions/{transactionId} {
         allow create: if isAttendant();
         allow read, update: if (isAttendant() && request.auth.uid == attendantId) || isAdmin();
         allow update: if isAttendant() && isValidTransactionUpdate();
       }

       match /notifications/{notificationId} {
         allow create, read: if (isAttendant() && request.auth.uid == attendantId) || isAdmin();
         allow update: if isAttendant();
       }

       match /messages/{messageId} {
         allow create, read, update, delete: if (isAttendant() && request.auth.uid == attendantId) || isAdmin();
         allow create, read, update, delete: if isAdmin() && exists(/databases/$(database)/documents/attendants/$(request.resource.data.receiverId));
       }
     }

     match /clients/{clientId} {
       // Owner check for the client document itself (no get() recursion)
       allow read, write: if isSignedIn() && (
         (resource.data.email == request.auth.token.email || resource.data.uid == request.auth.uid)
         || isAdmin()
         || isAttendant()
       );

       match /transactions/{transactionId} {
         // Client creates the copy in their own subcollection as part of the batch
         allow create: if isAttendant() || isClientOwner(clientId);
         allow read, update: if isSignedIn() && (isClientOwner(clientId) || isAdmin() || isAttendant());
         allow update: if isAttendant() && isValidTransactionUpdate();
       }

       match /drafts/{draftId} {
         // Fix drafts loading for the client
         allow read, write: if isSignedIn() && (isClientOwner(clientId) || isAdmin());
       }

       match /notifications/{notificationId} {
         allow read, write: if isSignedIn() && (isClientOwner(clientId) || isAdmin());
       }
     }

     match /transactions/{transactionId} {
       // Fix: allow clients to create their own pending transactions (app writes to /transactions)
       allow create: if isAttendant() || (
         isSignedIn()
         && request.resource.data.status == 'pending'
         && request.resource.data.clientId is string
         && isClientOwner(request.resource.data.clientId)
         && request.resource.data.clientEmail == request.auth.token.email
       );

       // Fix: clients can read only their own transactions (app queries by clientEmail)
       allow read: if isAdmin() || isAttendant() || (
         isSignedIn() && resource.data.clientEmail == request.auth.token.email
       );

       allow update: if isAttendant() && isValidTransactionUpdate();
     }

     match /notifications/{notificationId} {
       allow update: if isAttendant();
       allow read: if isSignedIn();
       allow write: if isSignedIn() && (isAdmin() || request.auth.uid == get(/databases/$(database)/documents/notifications/$(notificationId)).data.clientId);
     }

     match /prices/{priceId} {
       allow read: if isAttendant() || isAdmin();
       allow write: if isAdmin();
     }

     match /transactions/{transactionId} {
       allow update: if isValidTransactionUpdate();
     }
   }
 }
